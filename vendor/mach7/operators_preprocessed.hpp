//
//  Mach7: Pattern Matching Library for C++
//
//  Copyright 2011-2013, Texas A&M University.
//  Copyright 2014 Yuriy Solodkyy.
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//      * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//
//      * Redistributions in binary form must reproduce the above copyright
//        notice, this list of conditions and the following disclaimer in the
//        documentation and/or other materials provided with the distribution.
//
//      * Neither the names of Mach7 project nor the names of its contributors
//        may be used to endorse or promote products derived from this software
//        without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY
//  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

///
/// \file
///
/// This file is a part of Mach7 library.
///
/// \author Yuriy Solodkyy <yuriy.solodkyy@gmail.com>
///
/// \see https://parasol.tamu.edu/mach7/
/// \see https://github.com/solodon4/Mach7
/// \see https://github.com/solodon4/SELL
///

#if defined(__GNUC__)
template <typename E1> inline auto operator-(E1&& e1) noexcept -> typename std::enable_if<mch::is_expression<E1>::value, typename mch::filtered_result<mch::unary_minus,       E1>::type >::type { return mch::make_expr<mch::unary_minus>       (mch::filter(std::forward<E1>(e1))); }
template <typename E1> inline auto operator~(E1&& e1) noexcept -> typename std::enable_if<mch::is_expression<E1>::value, typename mch::filtered_result<mch::bit_complement, E1>::type >::type { return mch::make_expr<mch::bit_complement> (mch::filter(std::forward<E1>(e1))); }
// -- commented in favor of negation combinator template <typename E1> inline auto operator!(E1&& e1) noexcept -> typename std::enable_if<mch::is_expression<E1>::value, typename mch::filtered_result<mch::bool_complement,E1>::type >::type { return mch::make_expr<mch::bool_complement>(mch::filter(std::forward<E1>(e1))); }

template <typename E1, typename E2> inline auto operator+ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::addition,       E1,E2>::type >::type { return mch::make_expr<mch::addition>       (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator- (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::subtraction,    E1,E2>::type >::type { return mch::make_expr<mch::subtraction>    (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator* (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::multiplication, E1,E2>::type >::type { return mch::make_expr<mch::multiplication> (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator/ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::division,       E1,E2>::type >::type { return mch::make_expr<mch::division>       (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator% (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::modulo,         E1,E2>::type >::type { return mch::make_expr<mch::modulo>         (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator& (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::bit_and,        E1,E2>::type >::type { return mch::make_expr<mch::bit_and>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator| (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::bit_or,         E1,E2>::type >::type { return mch::make_expr<mch::bit_or>         (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator^ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::bit_xor,        E1,E2>::type >::type { return mch::make_expr<mch::bit_xor>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<<(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::bit_shift_left, E1,E2>::type >::type { return mch::make_expr<mch::bit_shift_left> (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>>(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::bit_shift_right,E1,E2>::type >::type { return mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
// -- commented in favor of conjunction combinator template <typename E1, typename E2> inline auto operator&&(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::bool_and,       E1,E2>::type >::type { return mch::make_expr<mch::bool_and>       (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
//template <typename E1, typename E2> inline auto operator||(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::bool_or,        E1,E2>::type >::type { return mch::make_expr<mch::bool_or>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator==(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::equal,          E1,E2>::type >::type { return mch::make_expr<mch::equal>          (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator!=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::not_equal,      E1,E2>::type >::type { return mch::make_expr<mch::not_equal>      (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator> (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::greater,        E1,E2>::type >::type { return mch::make_expr<mch::greater>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::greater_equal,  E1,E2>::type >::type { return mch::make_expr<mch::greater_equal>  (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator< (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::less,           E1,E2>::type >::type { return mch::make_expr<mch::less>           (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, typename mch::filtered_result<mch::less_equal,     E1,E2>::type >::type { return mch::make_expr<mch::less_equal>     (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
#endif

#if !defined(__GNUC__)

template <typename E1> inline auto operator-(E1&& e1) noexcept -> typename std::enable_if<mch::is_expression<E1>::value, mch::expr<mch::unary_minus,       decltype(mch::filter(std::forward<E1>(e1)))> >::type { return mch::make_expr<mch::unary_minus>       (mch::filter(std::forward<E1>(e1))); }
template <typename E1> inline auto operator~(E1&& e1) noexcept -> typename std::enable_if<mch::is_expression<E1>::value, mch::expr<mch::bit_complement, decltype(mch::filter(std::forward<E1>(e1)))> >::type { return mch::make_expr<mch::bit_complement> (mch::filter(std::forward<E1>(e1))); }
// -- commented in favor of negation combinator template <typename E1> inline auto operator!(E1&& e1) noexcept -> typename std::enable_if<mch::is_expression<E1>::value, mch::expr<mch::bool_complement,decltype(mch::filter(std::forward<E1>(e1)))> >::type { return mch::make_expr<mch::bool_complement>(mch::filter(std::forward<E1>(e1))); }

template <typename E1, typename E2> inline auto operator+ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::addition,       decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::addition>       (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator- (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::subtraction,    decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::subtraction>    (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator* (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::multiplication, decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::multiplication> (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator/ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::division,       decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::division>       (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator% (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::modulo,         decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::modulo>         (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator& (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::bit_and,        decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::bit_and>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator| (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::bit_or,         decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::bit_or>         (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator^ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::bit_xor,        decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::bit_xor>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<<(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::bit_shift_left, decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::bit_shift_left> (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>>(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::bit_shift_right,decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
// -- commented in favor of conjunction combinator template <typename E1, typename E2> inline auto operator&&(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::bool_and,       decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::bool_and>       (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
//template <typename E1, typename E2> inline auto operator||(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::bool_or,        decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::bool_or>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator==(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::equal,          decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::equal>          (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator!=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::not_equal,      decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::not_equal>      (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator> (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::greater,        decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::greater>        (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::greater_equal,  decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::greater_equal>  (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator< (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::less,           decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::less>           (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<mch::either_is_expression<E1,E2>::value, mch::expr<mch::less_equal,     decltype(mch::filter(std::forward<E1>(e1))),decltype(mch::filter(std::forward<E2>(e2)))> >::type { return mch::make_expr<mch::less_equal>     (mch::filter(std::forward<E1>(e1)),mch::filter(std::forward<E2>(e2))); }

#else

//template <typename T>                            inline auto operator-( mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::unary_minus>(mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::unary_minus>(mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T>                            inline auto operator-(const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::unary_minus>(v)) { return /*(*/mch::make_expr<mch::unary_minus>(v)/*)*/; }
//template <typename F1, typename E1>              inline auto operator-(const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::unary_minus>(v)) { return /*(*/mch::make_expr<mch::unary_minus>(v)/*)*/; }
//template <typename F1, typename E1, typename E2> inline auto operator-(const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::unary_minus>(v)) { return /*(*/mch::make_expr<mch::unary_minus>(v)/*)*/; }
//template <typename T>                            inline auto operator~( mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_complement>(mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_complement>(mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T>                            inline auto operator~(const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_complement>(v)) { return /*(*/mch::make_expr<mch::bit_complement>(v)/*)*/; }
//template <typename F1, typename E1>              inline auto operator~(const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bit_complement>(v)) { return /*(*/mch::make_expr<mch::bit_complement>(v)/*)*/; }
//template <typename F1, typename E1, typename E2> inline auto operator~(const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bit_complement>(v)) { return /*(*/mch::make_expr<mch::bit_complement>(v)/*)*/; }
//template <typename T>                            inline auto operator!( mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_complement>(mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bool_complement>(mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T>                            inline auto operator!(const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_complement>(v)) { return /*(*/mch::make_expr<mch::bool_complement>(v)/*)*/; }
//template <typename F1, typename E1>              inline auto operator!(const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bool_complement>(v)) { return /*(*/mch::make_expr<mch::bool_complement>(v)/*)*/; }
//template <typename F1, typename E1, typename E2> inline auto operator!(const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bool_complement>(v)) { return /*(*/mch::make_expr<mch::bool_complement>(v)/*)*/; }

//template <typename T, typename E>                             inline auto operator+( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator+( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::addition,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::addition>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator+(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::addition>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::addition>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator+( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::addition>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::addition>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator+(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::addition>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::addition>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator+( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::addition>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::addition>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator+(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::addition>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::addition>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator+( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::addition>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::addition>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator+(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::addition>(v,c)) { return /*(*/mch::make_expr<mch::addition>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator+( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator+(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::addition>(a,b)) { return /*(*/mch::make_expr<mch::addition>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator+( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator+(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::addition>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::addition>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::addition>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::addition>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::addition>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::addition>(e,c)) { return /*(*/mch::make_expr<mch::addition>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::addition>(c,e)) { return /*(*/mch::make_expr<mch::addition>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator-( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator-( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::subtraction,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::subtraction>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator-(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::subtraction>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::subtraction>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator-( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::subtraction>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::subtraction>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator-(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::subtraction>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::subtraction>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator-( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::subtraction>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::subtraction>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator-(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::subtraction>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::subtraction>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator-( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::subtraction>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::subtraction>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator-(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::subtraction>(v,c)) { return /*(*/mch::make_expr<mch::subtraction>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator-( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator-(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::subtraction>(a,b)) { return /*(*/mch::make_expr<mch::subtraction>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator-( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator-(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::subtraction>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::subtraction>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::subtraction>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::subtraction>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::subtraction>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::subtraction>(e,c)) { return /*(*/mch::make_expr<mch::subtraction>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::subtraction>(c,e)) { return /*(*/mch::make_expr<mch::subtraction>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator*( mch::var<T>& v, E&& e) noexcept -> mch::expr<mch::multiplication,mch::ref2<mch::var<T>>,decltype(mch::filter(std::forward<E>(e)))> { return /*(*/mch::make_expr<mch::multiplication>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator*( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::multiplication,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::multiplication>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator*(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::multiplication>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::multiplication>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator*( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::multiplication>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::multiplication>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator*(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::multiplication>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::multiplication>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator*( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::multiplication>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::multiplication>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator*(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::multiplication>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::multiplication>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator*( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::multiplication>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::multiplication>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator*(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::multiplication>(v,c)) { return /*(*/mch::make_expr<mch::multiplication>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator*( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::multiplication>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::multiplication>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator*(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::multiplication>(a,b)) { return /*(*/mch::make_expr<mch::multiplication>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator*( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::multiplication>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::multiplication>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator*(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::multiplication>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::multiplication>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::multiplication>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::multiplication>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::multiplication>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::multiplication>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::multiplication>(e,c)) { return /*(*/mch::make_expr<mch::multiplication>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::multiplication>(c,e)) { return /*(*/mch::make_expr<mch::multiplication>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator/( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator/( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::division,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::division>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator/(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::division>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::division>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator/( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::division>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::division>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator/(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::division>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::division>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator/( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::division>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::division>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator/(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::division>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::division>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator/( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::division>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::division>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator/(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::division>(v,c)) { return /*(*/mch::make_expr<mch::division>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator/( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator/(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::division>(a,b)) { return /*(*/mch::make_expr<mch::division>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator/( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator/(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::division>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::division>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::division>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::division>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::division>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::division>(e,c)) { return /*(*/mch::make_expr<mch::division>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::division>(c,e)) { return /*(*/mch::make_expr<mch::division>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator%( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator%( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::modulo,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::modulo>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator%(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::modulo>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::modulo>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator%( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::modulo>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::modulo>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator%(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::modulo>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::modulo>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator%( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::modulo>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::modulo>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator%(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::modulo>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::modulo>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator%( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::modulo>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::modulo>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator%(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::modulo>(v,c)) { return /*(*/mch::make_expr<mch::modulo>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator%( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator%(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::modulo>(a,b)) { return /*(*/mch::make_expr<mch::modulo>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator%( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator%(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::modulo>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::modulo>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::modulo>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::modulo>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::modulo>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::modulo>(e,c)) { return /*(*/mch::make_expr<mch::modulo>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::modulo>(c,e)) { return /*(*/mch::make_expr<mch::modulo>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator&( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::bit_and,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::bit_and>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator&(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_and>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_and>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_and>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_and>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_and>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_and>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bit_and>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_and>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_and>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_and>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bit_and>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_and>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator&(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_and>(v,c)) { return /*(*/mch::make_expr<mch::bit_and>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator&(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::bit_and>(a,b)) { return /*(*/mch::make_expr<mch::bit_and>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator&( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_and>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_and>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_and>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_and>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::bit_and>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::bit_and>(e,c)) { return /*(*/mch::make_expr<mch::bit_and>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_and>(c,e)) { return /*(*/mch::make_expr<mch::bit_and>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator|( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator|( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::bit_or,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::bit_or>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator|(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_or>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_or>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator|( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_or>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_or>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator|(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_or>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_or>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator|( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bit_or>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_or>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator|(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_or>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_or>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator|( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bit_or>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_or>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator|(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_or>(v,c)) { return /*(*/mch::make_expr<mch::bit_or>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator|( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator|(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::bit_or>(a,b)) { return /*(*/mch::make_expr<mch::bit_or>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator|( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator|(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_or>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_or>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_or>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_or>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::bit_or>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::bit_or>(e,c)) { return /*(*/mch::make_expr<mch::bit_or>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_or>(c,e)) { return /*(*/mch::make_expr<mch::bit_or>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator^( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator^( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::bit_xor,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::bit_xor>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator^(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_xor>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_xor>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator^( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_xor>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_xor>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator^(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_xor>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_xor>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator^( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bit_xor>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_xor>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator^(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_xor>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_xor>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator^( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bit_xor>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_xor>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator^(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_xor>(v,c)) { return /*(*/mch::make_expr<mch::bit_xor>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator^( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator^(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::bit_xor>(a,b)) { return /*(*/mch::make_expr<mch::bit_xor>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator^( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator^(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_xor>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_xor>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_xor>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_xor>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::bit_xor>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::bit_xor>(e,c)) { return /*(*/mch::make_expr<mch::bit_xor>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_xor>(c,e)) { return /*(*/mch::make_expr<mch::bit_xor>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator<<( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<<( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::bit_shift_left,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::bit_shift_left>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator<<(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_left>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<<( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_shift_left>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<<(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_left>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<<( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_shift_left>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<<(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_left>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<<( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_shift_left>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(v,c)) { return /*(*/mch::make_expr<mch::bit_shift_left>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator<<(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(a,b)) { return /*(*/mch::make_expr<mch::bit_shift_left>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_shift_left>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_shift_left>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::bit_shift_left>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(e,c)) { return /*(*/mch::make_expr<mch::bit_shift_left>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_left>(c,e)) { return /*(*/mch::make_expr<mch::bit_shift_left>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator>>( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>>( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::bit_shift_right,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator>>(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_right>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>>( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>>(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_right>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>>( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>>(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bit_shift_right>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>>( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bit_shift_right>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(v,c)) { return /*(*/mch::make_expr<mch::bit_shift_right>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator>>(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(a,b)) { return /*(*/mch::make_expr<mch::bit_shift_right>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_shift_right>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bit_shift_right>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::bit_shift_right>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(e,c)) { return /*(*/mch::make_expr<mch::bit_shift_right>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bit_shift_right>(c,e)) { return /*(*/mch::make_expr<mch::bit_shift_right>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator&&( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&&( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::bool_and,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::bool_and>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator&&(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_and>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_and>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&&( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_and>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bool_and>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&&(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_and>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_and>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&&( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bool_and>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bool_and>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&&(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_and>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_and>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&&( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bool_and>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bool_and>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bool_and>(v,c)) { return /*(*/mch::make_expr<mch::bool_and>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator&&(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::bool_and>(a,b)) { return /*(*/mch::make_expr<mch::bool_and>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_and>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bool_and>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_and>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bool_and>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::bool_and>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::bool_and>(e,c)) { return /*(*/mch::make_expr<mch::bool_and>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bool_and>(c,e)) { return /*(*/mch::make_expr<mch::bool_and>(c,e)/*)*/; }

#if 0
#error Commented in favor of disjunction combinator
template <typename T, typename E>                             inline auto operator||( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
template <typename T, typename E>                             inline auto operator||( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::bool_or,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::bool_or>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
template <typename T, typename E>                             inline auto operator||(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_or>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_or>(v,mch::filter(std::forward<E>(e)))/*)*/; }
template <typename T, typename E>                             inline auto operator||( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_or>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bool_or>(mch::filter(std::forward<E>(e)),v)/*)*/; }
template <typename F1, typename E1, typename E>               inline auto operator||(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_or>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_or>(v,mch::filter(std::forward<E>(e)))/*)*/; }
template <typename F1, typename E1, typename E>               inline auto operator||( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::bool_or>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bool_or>(mch::filter(std::forward<E>(e)),v)/*)*/; }
template <typename F1, typename E1, typename E2, typename E>  inline auto operator||(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::bool_or>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::bool_or>(v,mch::filter(std::forward<E>(e)))/*)*/; }
template <typename F1, typename E1, typename E2, typename E>  inline auto operator||( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::bool_or>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::bool_or>(mch::filter(std::forward<E>(e)),v)/*)*/; }
template <typename T, typename U>                             inline auto operator||(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bool_or>(v,c)) { return /*(*/mch::make_expr<mch::bool_or>(v,c)/*)*/; }
template <typename T, typename U>                             inline auto operator||( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator||(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::bool_or>(a,b)) { return /*(*/mch::make_expr<mch::bool_or>(a,b)/*)*/; }
template <typename T, typename U>                             inline auto operator||( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
template <typename T, typename U>                             inline auto operator||(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_or>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bool_or>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::bool_or>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::bool_or>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::bool_or>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::bool_or>(e,c)) { return /*(*/mch::make_expr<mch::bool_or>(e,c)/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::bool_or>(c,e)) { return /*(*/mch::make_expr<mch::bool_or>(c,e)/*)*/; }
#endif

//template <typename T, typename E>                             inline auto operator==( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator==( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::equal,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::equal>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator==(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator==( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator==(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator==( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator==(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator==( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator==(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::equal>(v,c)) { return /*(*/mch::make_expr<mch::equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator==( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator==(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::equal>(a,b)) { return /*(*/mch::make_expr<mch::equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator==( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator==(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::equal>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::equal>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::equal>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::equal>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::equal>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::equal>(e,c)) { return /*(*/mch::make_expr<mch::equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::equal>(c,e)) { return /*(*/mch::make_expr<mch::equal>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator!=( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator!=( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::not_equal,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::not_equal>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator!=(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::not_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::not_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator!=( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::not_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::not_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator!=(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::not_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::not_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator!=( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::not_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::not_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator!=(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::not_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::not_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator!=( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::not_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::not_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::not_equal>(v,c)) { return /*(*/mch::make_expr<mch::not_equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator!=(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::not_equal>(a,b)) { return /*(*/mch::make_expr<mch::not_equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::not_equal>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::not_equal>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::not_equal>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::not_equal>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::not_equal>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::not_equal>(e,c)) { return /*(*/mch::make_expr<mch::not_equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::not_equal>(c,e)) { return /*(*/mch::make_expr<mch::not_equal>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator>( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::greater,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::greater>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator>(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::greater>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::greater>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::greater>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::greater>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::greater>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::greater>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator>(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::greater>(v,c)) { return /*(*/mch::make_expr<mch::greater>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator>(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::greater>(a,b)) { return /*(*/mch::make_expr<mch::greater>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator>( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::greater>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::greater>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::greater>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::greater>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::greater>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::greater>(e,c)) { return /*(*/mch::make_expr<mch::greater>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::greater>(c,e)) { return /*(*/mch::make_expr<mch::greater>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator>=( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>=( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::greater_equal,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::greater_equal>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator>=(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>=( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::greater_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::greater_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>=(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>=( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::greater_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::greater_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>=(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::greater_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::greater_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>=( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::greater_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::greater_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::greater_equal>(v,c)) { return /*(*/mch::make_expr<mch::greater_equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator>=(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::greater_equal>(a,b)) { return /*(*/mch::make_expr<mch::greater_equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::greater_equal>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::greater_equal>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::greater_equal>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::greater_equal>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::greater_equal>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::greater_equal>(e,c)) { return /*(*/mch::make_expr<mch::greater_equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::greater_equal>(c,e)) { return /*(*/mch::make_expr<mch::greater_equal>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator<( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::less,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::less>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator<(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::less>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::less>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::less>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::less>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::less>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::less>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator<(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::less>(v,c)) { return /*(*/mch::make_expr<mch::less>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator<(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::less>(a,b)) { return /*(*/mch::make_expr<mch::less>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator<( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::less>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::less>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::less>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::less>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::less>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::less>(e,c)) { return /*(*/mch::make_expr<mch::less>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::less>(c,e)) { return /*(*/mch::make_expr<mch::less>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator<=( mch::var<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<=( E&& e, mch::var<T>& v) noexcept -> mch::expr<mch::less_equal,decltype(mch::filter(std::forward<E>(e))),mch::ref2<mch::var<T>>> { return mch::make_expr<mch::less_equal>(mch::filter(std::forward<E>(e)),mch::ref2<mch::var<T>>(v)); }
//template <typename T, typename E>                             inline auto operator<=(const mch::value<T>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<=( E&& e, const mch::value<T>& v) noexcept -> decltype(mch::make_expr<mch::less_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::less_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<=(const mch::expr<F1,E1>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<=( E&& e, const mch::expr<F1,E1>& v) noexcept -> decltype(mch::make_expr<mch::less_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::less_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<=(const mch::expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(mch::make_expr<mch::less_equal>(v,mch::filter(std::forward<E>(e)))) { return /*(*/mch::make_expr<mch::less_equal>(v,mch::filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<=( E&& e, const mch::expr<F1,E1,E2>& v) noexcept -> decltype(mch::make_expr<mch::less_equal>(mch::filter(std::forward<E>(e)),v)) { return /*(*/mch::make_expr<mch::less_equal>(mch::filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=(const mch::value<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::less_equal>(v,c)) { return /*(*/mch::make_expr<mch::less_equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=( mch::var<T>& v, mch::var<U>& w) noexcept -> decltype(mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))) { return /*(*/mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),mch::ref2<mch::var<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator<=(const mch::expr<F1,E1,E2>& a, const mch::expr<F2,E3,E4>& b) noexcept -> decltype(mch::make_expr<mch::less_equal>(a,b)) { return /*(*/mch::make_expr<mch::less_equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=( mch::var<T>& v, const mch::value<U>& c) noexcept -> decltype(mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),c)) { return /*(*/mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=(const mch::value<U>& c, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::less_equal>(c,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::less_equal>(c,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=(const mch::expr<F1,E1,E2>& e, mch::var<T>& v) noexcept -> decltype(mch::make_expr<mch::less_equal>(e,mch::ref2<mch::var<T>>(v))) { return /*(*/mch::make_expr<mch::less_equal>(e,mch::ref2<mch::var<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=( mch::var<T>& v, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),e)) { return /*(*/mch::make_expr<mch::less_equal>(mch::ref2<mch::var<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=(const mch::expr<F1,E1,E2>& e, const mch::value<T>& c) noexcept -> decltype(mch::make_expr<mch::less_equal>(e,c)) { return /*(*/mch::make_expr<mch::less_equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=(const mch::value<T>& c, const mch::expr<F1,E1,E2>& e) noexcept -> decltype(mch::make_expr<mch::less_equal>(c,e)) { return /*(*/mch::make_expr<mch::less_equal>(c,e)/*)*/; }
#endif

[analyze-usage]:
  [function]:
    ✔ Mark non-local -use/assign @done(2015-07-24 23:43) @project([analyze-usage] / [function])
    ✔ Check non-local use/assign validity on call @done(2015-07-24 23:43) @project([analyze-usage] / [function])
    ✔ Parameters (**) @done(2015-07-29 10:51) @project([analyze-usage] / [function])
    ✔ Recursion (*) @done(2015-07-29 10:13) @project([analyze-usage] / [function])

  ☐ Loop
  ✔ Import @done(2015-07-31 14:48) @project([analyze-usage])


[analyze-type]:
  ☐ Scope crossing doesn't work for variable contextual deduce (***)
  ✔ CTA @done(2015-07-25 06:52) @project([analyze-type])
  ☐ type(..) expression (****)
  ☐ CTA for tuples


[check-type]:
  ☐ Assign (initializer and assign)
  ☐ Call (operand)
  ☐ Call (parameters)
  ☐ Cast (explicit)
  ☐ Return
  ☐ Select (condition)


[resolve]:
  ☐ Function
  ✔ Select @done(2015-07-25 06:52) @project([resolve])
  ✔ CTA @done(2015-07-25 06:52) @project([resolve])
  ☐ When CTA is applied to two compatible function types; merge the assign/use pools (*****)


[build]:
  [function]:
    ✔ Parameters @done(2015-07-29 10:51) @project([build] / [function])
    ✔ Return @done(2015-07-25 06:52) @project([build] / [function])

  ✔ Select @done(2015-07-25 07:21) @project([build])
  ☐ Cast each branch in a select expression (that has a value)
  ☐ Loop
  ☐ Unary
  ☐ Binary

  ☐ Import
    ✔ Function @done(2015-07-31 14:48) @project([build] / [function])
    ✔ Extern Function @done(2015-07-31 14:48) @project([build] / [function])
    ✔ Extern Slot @done(2015-07-31 14:48) @project([build] / [function])
    ✔ Slot (..) @done(2015-07-31 18:15) @project([build] / [function])
    ☐ Initializer Resolution (Hard Mode)
      ☐ All "constant" initialization (that is exported) goes into a
        common list (that is sorted as we go along); at the end, this
        list is pushed into a global ".init" that is run before any module
        initializers
      ☐ Detect "constant" initializers that cyclically depend on another
        "constant" initializer (eg. "(in a) let a = b.b; (in b) let b = a.a")
        and error the fuck out
      ☐ All module initializers (that got imported at some point) are ran
        in an arbitrary order with the "entry" module being last
    ☐ Test: Function
    ☐ Test: Extern Function
    ☐ Test: Extern Slot
    ☐ Test: Slot (Basic)
    ☐ Test: Slot (Cyclical)
    ☐ Test: Slot (Unresolvable)


[...]:
  ☐ Parameter (Unpack)
  ☐ Qualified names `x.method` (for functions and global variables)


[error-checking]:
  ☐ Duplicate function names in same module (error)
  ☐ Duplicate exported slot names in same module (error)
  ☐ Attempting to unpack a non-tuple or a tuple of the wrong size (error)
  ☐ Use/Assign before declare (should error; segfaults currently)
  ☐ Relativize (from CWD) all error message filenames


language-arrow:
  ☐ Add underscores (`1_3_4`) to number patterns
  ☐ Add function parameters
  ☐ Fix `export/extern let x` (not pushing `x` as a variable)
  ☐ Make `;` optional
  ☐ Add shebang as a comment-type
  ☐ Escape sequences in strings
